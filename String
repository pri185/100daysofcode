For two strings s and t, we say "t divides s" if and only if s = t + ... + t (i.e., t is concatenated with itself one or more times).

Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2.

 class Solution {
public:
    string gcdOfStrings(string str1, string str2) {
        return (str1 + str2 == str2 + str1)? 
        str1.substr(0, gcd(size(str1),size(str2))): "";
    }
};

(P/2)
Given a string s consisting of words and spaces, return the length of the last word in the string.

class Solution {
public:
    int lengthOfLastWord(string s) { 
        int len = 0, lastword = s.length() - 1;
        while (lastword >= 0 && s[lastword] == ' ') 
        lastword--;
        while (lastword >= 0 && s[lastword] != ' ') {
            len++;
            lastword--;
        }
        return len;
    }
};



(P/4)
The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

class Solution {
public:

    string convert(string s, int numRows) {
    
    if(numRows <= 1) return s;

    vector<string>v(numRows, ""); 

    int j = 0, dir = -1;

    for(int i = 0; i < s.length(); i++)
    {

        if(j == numRows - 1 || j == 0) dir *= (-1); 
		 
        v[j] += s[i];

        if(dir == 1) j++;

        else j--;
    }

    string res;

    for(auto &it : v) res += it; 

    return res;

    }
};

(P/5)
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
class Solution {
public:
    int romanToInt(string s) {
         int temp=0;
        int n=s.length();
        int arr[n];
        for(int i=0; i<n; i++)
        {
            if(s[i]=='I')
            arr[i]= 1;
            else if(s[i]=='V')
            arr[i]= 5;
            else if(s[i]=='X')
            arr[i]= 10;
            else if(s[i]=='L')
            arr[i]= 50;
            else if(s[i]=='C')
            arr[i]= 100;
            else if(s[i]=='D')
            arr[i]=  500;
            else if(s[i]=='M')
            arr[i]= 1000;
        }
        
        for(int i=n-1; i>0; i--)
        {
            temp += arr[i];
            
            if(arr[i]>arr[i-1])
            temp -= 2*arr[i-1];   
        }
        temp += arr[0];
        return temp;
    }
};

P/6 -- medium
Given two strings s and part, perform the following operation on s until all occurrences of the substring part are removed:

Find the leftmost occurrence of the substring part and remove it from s.
Return s after removing all occurrences of part.

class Solution {
public:
    string removeOccurrences(string s, string part) {
        while(s.length()!=0 && s.find(part)<s.length()){
        s.erase(s.find(part),part.length());
        }
       return s;
    }
};
p/7You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int n= digits.size();
        for(int i=n-1; i>=0; i--){
            if(digits[i]<9){
                digits[i]+=1;
                return digits;
            }
            else{
                digits[i]=0;
            }
        }
        digits[0]=1;
        digits.push_back(0);
        return digits;        
    }
};
